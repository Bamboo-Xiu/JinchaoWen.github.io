<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin 学习笔记（一）]]></title>
    <url>%2F2021%2F07%2F04%2F6-Kotlin-Study-Note-1%2F</url>
    <content type="text"><![CDATA[最近开始学习 Kotlin 语言了，打算搞个笔记系列，这是首篇~ 1. 基本类型123var age: Int = 123 // 标准语法，声明一个可变变量 ageval name: String = &quot;Tom&quot; // 标准语法，声明一个不可变变量 name (不可变变量不是常量)val sex: String? = null // 声明一个可为空的字符串变量 sex，String 与 String? 不是同种类型 String 和 String? 是两种类型，前者修饰的变量不可为 null 空值；后者加了 “?” 之后修饰的变量就可以为 null 了，这也是 kotlin 空安全的一种体现。 当编译器可以推断出变量的数据类型时，可以不用写冒号和后面的数据类型，例如：12var age = 123 // 可推断出 age 为 Int，所以可不写val name = &quot;Tom&quot; // 可推断出 name 为 String，所以可不写 双感叹号 “!!” 可以强转类型，如下代码。 name2 是可为空的 String? 类型，直接赋给不可为空的 name1 就会报错。如果确定 name2 一定不为空，则可以在后面加上 “!!” 强转。1234var name1: String = &quot;Tom&quot; // name1 不可为空var name2: String? = &quot;Jack&quot;; // name2 可为空//name1 = name2 // 报错name1 = name2!! 2. 关键字 open 。被声明为 open 的 class 是可以被继承的，这里注意下 kotlin 中一个类是默认被修饰为 final 的，即默认的类是不能被继承的。 3. 函数kotlin 函数前有 fun 关键字，返回值类型要写在入参括号后和函数体大括号前：1234567891011121314fun main() &#123; printLen(&quot;栗子&quot;)&#125;fun printLen(str: String): String &#123; println(&quot;举个 $str !&quot;) // 这种写法类似于 C 语言了 return str&#125;// Kotlin 函数参数还可以设置默认值fun printLen(str: String = &quot;我是默认值~&quot;): String &#123; println(&quot;举个 $str !&quot;) // 这种写法类似于 C 语言了 return str&#125; 4. Kotlin 方法可以直接写在 .kt 文件里，不用写在某个类中例如有个 Util.kt 的文件，里面有许多工具类的方法，如果在 Java 中，就必须在类中编写代码：12345public class Utils &#123; public static final void echo(String name) &#123; println(&quot;name = &quot; + name); &#125;&#125; 调用时，就是：1Utils.echo(&quot;Hello UnderWorld! &quot;); 而在 Kotlin 代码中，可以直接在 Util.kt 文件中这么写：1234// Util.kt 文件fun echo(name: String) &#123; println(&quot;name = $name&quot;)&#125; 在 Java 代码里调用就可以直接这么写：1234// Main.java 文件public static void main(String[] args) &#123; UtilKt.echo(&quot;Hello World! &quot;);&#125; 5. 与 Java 代码之间的互调12345object Test &#123; // Kotlin 代码里 匿名内部类 的写法 fun say(msg: String) &#123; println(msg) &#125;&#125; 在 kotlin 代码中调用 Test 中的 say 方法：1Test.say(&quot;Good Morning~&quot;) 在 Java 代码中调用，则：1Test.INSTANCE.say(&quot;Good Morning~&quot;) 在 kotlin 中调用一个 Java 类，不能像在 Java 中一样写成这样： Test.class ，而是要这样写：Kotlin 类是被编译为 KClass 文件，而不是 class 文件。所以，在 Kotlin 代码里，如果要调用一个 Kotlin 的类，则不用加 .java 后缀，而是直接写成：```Util::class```。123## 6. Java 与 Kotlin 之间的冲突解决1. 关键字冲突。比如 in 这个关键字，在 Kotlin 中是一个关键字，如果要引用 Java 类中一个叫 in 的对象时，则需要用反引号 ` 解决这个冲突： Utils.in // 在 Utils.java 中，in 是一个属性：public static int in = 100;1234562. Kotlin 没有封装类。Kotlin 中没有像 Integer 的封装类，只有 Int 等基本类型，只有通过反射的方式才能调用或用于鉴别 Integer 的封装类类型。 这里给出几个网上应用的例子，实际中使用时，再补充。 1）在 kotlin 代码中使用 Integer.class。假如 Java 类中有方法：```void func(Class clazz)&#123;&#125;```，那么在 Kotlin 中如果需要传入一个 Integer.class 该怎么办？正确的做法是：```func(Int::class.javaObjectType)```，而不是```func(Int::class.java)``` 2）```Int::class.java```指向的是 kotlin 标准库中的 Int.kt ；```Int::class.javaObjectType```指向的是 JDK 里的 Integer.java 类。 3. Kotlin 是空安全的。Kotlin 如果调用了 Java 中的代码，则需要用 ***? 的类型来接收，这样可以防止空指针异常。例如 Java 中是 String 类型的对象，要在 Kotlin 中使用的话，需要用 String? 类型来接收。4. Kotlin 没有静态变量和静态方法。没有静态方法的问题，可以在方法前添加 @JvmStatic 注解来解决： object Utils { @JvmStatic fun getName(): String{ return “hehe” }}1234当然也可以将方法写在类的 ```companion object &#123;&#125;```中。## 7. 扩展函数kotlin 支持给原有的类添加一些扩展的功能，就是通过扩展函数来实现的。可以针对第三方库中对象添加一些我们需要的方法。例如我们可以扩展一下 User 类中的方法： fun User.getInfo(): String { // 原本的 User 类中是没有 getInfo 方法的 return uid.toString() + name}1这样，我们相当于给 User 类添加了一个方法 getInfo，然后 User 类的对象都可以调用 getInfo 方法了。请注意这里的扩展函数是静态添加给这个类的，不具备运行时的多态的。可以看下面的代码： open class Animal // 父类class Dog: Animal() // 子类 fun Animal.name() = “animal” // 父类扩展函数 name，返回 animalfun Dog.name() = “dog” // 子类扩展函数 name，返回 dog fun Animal.printName(animal: Animal) { // 父类扩展函数 printName，调用的是父类对象的 name 函数 println(animal.name())} fun main(args: Array) { Dog().printName(Dog()) // 打印的结果是 “animal”，这说明扩展函数不具备运行时多态的特点。}1234将这段代码反编译成 Java 代码，可以看到最终调用的 ```Dog().printName(Dog())``` 这段代码，被编译成了 ```printName((Animal)(new Dog()), (Animal)(new Dog()));``` ，即最后调用会将 Dog 对象强转为 Animal 对象，这样就不具有多态的特点了。## 8. Lambda 闭包1. Lambda 闭包声明，可以为： // lambda 闭包val print = {name: String -&gt; // 闭包名声明为 print，闭包还允许添加参数，这里声明了一个 name 的参数 println(name)}1234这里闭包中的参数个数是有限制的，上限为 22个。因为 Kotlin 只为我们定义了含有 22 个参数的 Function22，如图所示： ![图片.png](6-Kotlin-Study-Note-1/pic1.png) 如果我们需要用到 23个参数的 Lambda 闭包该怎么办呢？这个时候我们就需要手动声明一个kotlin包中的 Function23。这里需要手动定义一个 Java 类的 Function23，因为只有一个kotlin标准库才可以声明一个kotlin包名，而我们自己是不能声明一个类的包名为kotlin的，但是 Java和kotlin是互通的，所以我们可以将这个Function23 声明为一个 Java类，并将它的包名设置为kotlin，这样就可以声明参数个数超过 22 的闭包了。 package kotlin; public interface Function23&lt;P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15, P16, P17, P18, P19, P20, P21, P22, P23, R&gt; extends Function { R invoke(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, P9 p9, P10 p10, P11 p11, P12 p12, P13 p13, P14 p14, P15 p15, P16 p16, P17 p17, P18 p18, P19 p19, P20 p20, P21 p21, P22 p22, P23 p23);}1234## 9. 高阶函数高阶函数的特点：函数（Lambda）的参数也是一个函数（Lambda）。知识点1：函数默认的返回值为一个 Unit 类型的对象，可以不写。但如果这个函数是作为一个参数，那么返回类型一定要写: // 只有当 isDebug 为 true，才会执行后面的 block 函数. block 函数是作为一个参数，所以返回类型要显式写出fun Onlyif(isDebug: Boolean, block: () -&gt; Unit) { if (isDebug) block()} fun main() { val runnable = Runnable { print(“Runnable run!”) } val function: () -&gt; Unit function = runnable::run // Runnable 只有一个 run 方法，所以可以直接用双冒号进行调用 Onlyif(true, function)}12Kotlin 的 Lambda 会编译为一个匿名内部类，可以使用 inline 关键字来修饰方法，这样当方法在编译时就会拆解方法的调用为语句调用，进而减少创建不必要的对象。但要注意，过多使用 inline 关键字会增加编译器的编译负担，所以 inline 只适合修饰高阶函数，例如上述的高阶函数就可以用 inline 修饰： inline fun Onlyif(isDebug: Boolean, block: () -&gt; Unit) { if (isDebug) block()}1234## 10. 类与对象1. Kotlin 类默认是被 public final 修饰的，默认的父类是 Any，而不是 Object。2. Kotlin 类的构造函数会默认调用 init 方法，所以可以在 init 方法中执行一些初始化的操作： class TestView: View { constructor(context: Context): super(context) constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0) constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) init { print(&quot;构造函数已执行~&quot;) } }123. 四种访问修饰符，分别是 private、protected、public、internal。前三种与 Java 相同，internal 表示 module 模块内部是都可以访问的，而其他 module 是无法访问的。4. Kotlin 的伴生对象。可以实现静态方法和静态变量： class StringUtils { // 伴生对象 companion object { // 伴生对象实现静态变量 val TAG = “StringUitls” // 伴生对象实现静态方法 fun isEmpty(str: String) : Boolean { return “” == str } }}15. Kotlin 中的单例的实现。可以使用伴生对象来实现 kotlin 的单例： // 单例实现class SingleInstance private constructor() { companion object { fun get() : SingleInstance { return Holder.instance } } private object Holder { // 通过 object 创建一个匿名内部类 val instance = SingleInstance() } }` 还没看够？来我的公众号看看？搜索： 俢之竹或者扫一扫下面的二维码： 来知乎逛逛也是可以的，搜索： 俢之竹 参考文献 从Kotlin访问Integer.class Kotlin 调用Java写的方法，参数Class 神坑 ps. 赠人玫瑰，手留余香。欢迎转发分享，你的认可是我继续创作的精神源泉。]]></content>
      <tags>
        <tag>Android World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 动态代理学习与实践]]></title>
    <url>%2F2021%2F06%2F20%2F5-Kotlin-Dynamic-agent-Learning-and-Practice%2F</url>
    <content type="text"><![CDATA[最近接了个大项目，哈哈哈~ 文章终于出来啦~ 还好没胎死腹中。最近的感悟就是，做好小事，才有机会做大事，承担大项目！这次的文章本来想写 Kotlin 学习笔记2，结果写着写着发现动态代理这块之前还是没搞明白，所以就学了下 Kotlin 中的代理模式写法，发现东西有点多，遂独自成文，欢迎大家拍砖！ 1. 引子动态代理主要是用来干什么的？通俗一点，就是你在调用其他类的一些方法时，想加入你自己的一些处理逻辑。比如说，统计这些方法的执行时长等，这也是面向切面编程的思想。 2. 代理模式动态代理，源自于设计模式中常见的一种模式：代理模式。在 Java 中就是为一个对象 A 的一个方法 B 提供一个代理对象，这个代理对象可以完全控制 A 对象的 B 方法实际的执行内容。四个关键词：1）代理对象；2）被代理对象；3）被代理行为；4）对行为的完全控制。 这样说还是太抽象，举个实际的例子。假如我们需要通过房屋中介租房，就是一个简单的代理模式。这里面有三种角色：1）房东——被代理对象；2）房屋中介——代理对象；3）租客——使用方或调用者。房东把全部的租房事项全部交给中介打理，那么中介就具有对租房行为的完全控制，租客只能跟中介打交道。 看看上面的四个关键词，中介 对应 代理对象；房东 对应 被代理对象；租房相关事项 对应 被代理行为，比如找租客、约看房时间、看房、签约等；中介可以完全控制对租房事项的行为 对应 对行为的完全控制，比如中介可以加价，提供保洁服务等。 2.1 代理模式的基本要素 代理对象与被代理对象需要实现相同的接口。即对于出租房屋来说，就是出租房屋的相关事项，房东和中介都必须完成的出租流程手续。 代理对象中有被代理对象的引用，这样外部调用者在调用代理对象的方法时，代理对象就会在内部交给被代理对象去实际执行。即，中介可以代替房东去出租房屋，最终决定权还是在房东手里。 外部调用者是直接使用接口进行调用的，对被代理对象的信息有一定的保护作用。即，租客只能通过出租房屋的流程手续与中介进行沟通，并不知道房东的个人信息。 2.2 租房代码实例 - Java 版Talk is cheap，Show me your Code! 我们具体来看看代码怎么表示。首先是租房的一些流程，也就是被代理的行为，这里为方便只写了三个步骤。通常用抽象类或接口的形式表示：1234567891011// code 1interface IRentHouse &#123; // 带领租客看房 void visitHouse(); // 讨价还价 void argueRent(int rent); // 签合同 void signAgreement();&#125; 其次，房东的实现，也就是被代理对象的行为，房东的权利。1234567891011121314151617// code 2class HouseOwner implements IRentHouse&#123; @Override public void visitHouse() &#123; System.out.println(&quot;HouseOwner 带领看房，介绍房屋特点&quot;); &#125; @Override public void argueRent(int rent) &#123; System.out.println(&quot;HouseOwner 提出租金为：&quot; + rent); &#125; @Override public void signAgreement() &#123; System.out.println(&quot;HouseOwner 签合同&quot;); &#125;&#125; 接下来就是房屋中介的实现，因为中介得到了房东的授权，所以他可以有房东的所有权利，他代理房东去操作出租房屋的相关事项。因此，中介会先征求房东的同意，拿到授权，在代码中的表现就是持有房东的引用。1234567891011121314151617181920212223// code 3public class HouseAgent implements IRentHouse&#123; IRentHouse mHouseOwner; // 中介持有房东的权利 public HouseAgent(IRentHouse houseOwner) &#123; mHouseOwner = houseOwner; &#125; @Override public void visitHouse() &#123; mHouseOwner.visitHouse(); &#125; @Override public void argueRent(int rent) &#123; mHouseOwner.argueRent(rent); &#125; @Override public void signAgreement() &#123; mHouseOwner.signAgreement(); &#125;&#125; 在 main 方法中就可以如下调用了：12345// code 4HouseAgent agent = new HouseAgent(new HouseOwner()); // 传入房东对象，拿到授权agent.visitHouse();agent.argueRent(300);agent.signAgreement(); 这其实就是一个静态代理的例子。为啥是“静态”？因为这里的代理方法是写死的，如果 HouseOwner 对象新增方法，那么在 HouseAgent 和 接口中都得新增代码，不够灵活。 那么代理模式有什么作用？看起来好像就是代理类对被代理类做了一层封装而已，其实这层封装在一定程度上保护了被代理类的信息，使用者不用关心内部的具体实现。此外，代理类可以根据自身特点和客户需求进行功能扩展，在保证 HouseOwner 类的核心方法正确执行的情况下，扩展其他的行为。例如：租户刚毕业社会经验不足，遇到了一个黑心中介，需要在你看房前给小费：1234567891011121314151617181920212223242526272829303132// code 5public class HouseAgent implements IRentHouse&#123; IRentHouse mHouseOwner; // 中介持有房东的权利 int mTip = 0; // 小费 public HouseAgent(IRentHouse houseOwner) &#123; mHouseOwner = houseOwner; &#125; @Override public void visitHouse() &#123; if (mTip &gt; 10) &#123; mHouseOwner.visitHouse(); &#125; else &#123; System.out.println(&quot;小费不够，暂不能看房&quot;); &#125; &#125; @Override public void argueRent(int rent) &#123; mHouseOwner.argueRent(rent); &#125; @Override public void signAgreement() &#123; mHouseOwner.signAgreement(); &#125; public void giveTip(int tip) &#123; mTip = tip; &#125;&#125; 2.3 租房代码实例 - Kotlin 版上面静态代理的 Java 代码写起来虽然容易，但是套路都一样，显得繁琐。Kotlin 代码中，使用 by 关键字就可以了，非常方便，还是上面的例子，Kotlin 代码为：1234567891011121314151617181920212223242526272829303132// code 6interface IRentHouse &#123; // 带领租客看房 fun visitHouse() // 讨价还价 fun argueRent(rent: Int) // 签合同 fun signAgreement()&#125;class HouseOwner: IRentHouse &#123; override fun visitHouse() &#123; println(&quot;带领看房，介绍房屋特点&quot;) &#125; override fun argueRent(rent: Int) &#123; println(&quot;提出租金为：$rent&quot;) &#125; override fun signAgreement() &#123; println(&quot;签合同&quot;) &#125;&#125;class HouseAgent(houseOwner: IRentHouse): IRentHouse by houseOwner &#123;&#125;// 调用的代码如下HouseAgent(HouseOwner()).visitHouse()HouseAgent(HouseOwner()).argueRent(500)HouseAgent(HouseOwner()).signAgreement() 一个 by 关键字，就避免写很多重复的代码了。如果代理类要在原有的基础上添加自己的方法或功能，只需要在代理类中重写被代理对象中的方法。还是拿上面的例子说明：1234567891011121314151617// code 7class HouseAgent(houseOwner: IRentHouse): IRentHouse by houseOwner &#123; var mTip = 0 private val mHouseOwner = houseOwner fun giveTip(tip: Int)&#123; mTip = tip &#125; override fun visitHouse() &#123; if (mTip &gt; 10) &#123; mHouseOwner.visitHouse() &#125; else &#123; println(&quot;小费不够，暂不能看房&quot;) &#125; &#125;&#125; 所以，静态代理就是把代理关系的代码是写死的，若被代理对象添加了新的方法，那么代理类和接口都需要改动。当然如果是用 Kotlin 写，那么只需要对接口进行改动。但是，如果我们想要切面编程，在每个被代理对象的方法中添加自己的处理，比如，我需要知道每个方法步骤的执行用时，那么就得在每个方法调用前后记录时间戳，这就很繁琐了。而且每新增方法都得重复写相同的代码，这种情况下，就需要使用动态代理。 3. Java 动态代理实现创建 Java 的动态代理需要使用 Proxy 类：12// code 8java.lang.reflect.Proxy 调用它的 newProxyInstance 方法，就可以为某类创建一个代理类。例如给 Map 创建一个代理类：1234567891011// code 9Map mapProxy = (Map) Proxy.newProxyInstance( HashMap.class.getClassLoader(), new Class[]&#123;Map.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; return null; &#125; &#125;); 可以分析下这个方法，方法签名为：12// code 10public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) ClassLoader 类型的 loader 对象：被代理类的类加载器； Class 数组的 interfaces 对象：被代理的接口，对应于之前关键词中的 被代理的行为，这里传入的是接口而不是某个具体的类，所以表示行为； InvocationHandler 接口对象 h：代理的具体的行为，对应之前关键词中的 对行为的完全控制，这也是 Java 动态代理的核心； 返回的 Object 对象：对应之前关键词中的 代理对象。 所以，要实现一个动态代理大概需要下面几个步骤： 一、定义要被代理的行为例如 code1 就是定义的要被代理的行为。 二、定义被代理的对象就是实现了接口的类，例如实现了租房流程的房东，详见 code2。 三、建立代理关系这个是代理的核心，需要一个实现了 InvocationHandler 接口的类： 12345678910111213141516// code 11public class AgentHandler implements InvocationHandler &#123; private Object target; public AgentHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;方法执行前&quot;); Object result = method.invoke(target, args); System.out.println(&quot;方法执行后&quot;); return result; &#125;&#125; 接口中的 invoke 方法比较重要。方法体中的 Object 类型的 proxy 是最终生成的代理对象；Method 类型的 method 是被代理的方法；Object[] 数组类型的 args 是被代理方法执行所需要的参数。target 对象就是传入的代理类。在这个类中，可以在 invoke 方法前后插入我们需要执行的代码，这样做可以使得被代理类对象在执行任何方法时，都会执行我们插入的代码。例如，我们可以在 invoke 方法前后记录下时间戳，这样就可以得出被代理类对象执行的每一个方法的执行时长。 然后代理类利用 InvocationHandler 进行代理：12345678910111213141516// code 12public class HouseAgentSmart &#123; private IRentHouse mHouseOwner; // 房东，被代理类对象 public HouseAgentSmart(IRentHouse houseOwner) &#123; mHouseOwner = houseOwner; mHouseOwner = (IRentHouse) Proxy.newProxyInstance( houseOwner.getClass().getClassLoader(), new Class[]&#123;IRentHouse.class&#125;, new AgentHandler(mHouseOwner) // 将被代理对象传入 ); &#125; public IRentHouse getAccess() &#123; // 用于返回代理对象 return mHouseOwner; &#125;&#125; 四、执行者调用12345// code 13IRentHouse smartAgent = new HouseAgentSmart(new HouseOwner()).getAccess(); smartAgent.visitHouse(); smartAgent.argueRent(400); smartAgent.signAgreement(); 4. Kotlin 动态代理实现上面是动态代理的 Java 实现，那么如何用 Kotlin 实现？其实是一样的，只不过是编程语言的语法不同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// code 14// IRentHouseKT.kt 1、首先还是定义接口interface IRentHouseKT &#123; // 带领租客看房 fun visitHouse() // 讨价还价 fun argueRent(rent : Int) // 签合同 fun signAgreement()&#125;// HouseOwnerKT.kt 2、然后是被代理类，实现接口class HouseOwnerKT : IRentHouseKT &#123; override fun visitHouse() &#123; println(&quot;HouseOwner 带领看房，介绍房屋特点&quot;) &#125; override fun argueRent(rent: Int) &#123; println(&quot;HouseOwner 提出租金为：$rent&quot;) &#125; override fun signAgreement() &#123; println(&quot;HouseOwner 签合同&quot;) &#125;&#125;// AgentHandlerKT.kt 3、建立代理关系class AgentHandlerKT : InvocationHandler &#123; private var mTarget : Any? = null constructor(target : Any?) &#123; this.mTarget = target &#125; override fun invoke(proxy: Any?, method: Method, args: Array&lt;out Any&gt;?): Any? &#123; println(&quot;方法执行前&quot;) // 因为传来的参数 args 是不确定的，所以用 *args.orEmpty() 传参 val result = method.invoke(mTarget, *args.orEmpty()) println(&quot;方法执行后&quot;) return result &#125;&#125;// HouseAgentSmartKT.kt 4、代理类，通过 AgentHandlerKT 得到代理关系class HouseAgentSmartKT &#123; var mHouseOwner : IRentHouseKT? = null constructor(houseOwner : IRentHouseKT) &#123; mHouseOwner = houseOwner mHouseOwner = Proxy.newProxyInstance( houseOwner.javaClass.classLoader, arrayOf(IRentHouseKT::class.java), AgentHandlerKT(mHouseOwner) ) as IRentHouseKT &#125;&#125;// 调用方进行调用val smartAgent = HouseAgentSmartKT(HouseOwnerKT()).mHouseOwnersmartAgent?.visitHouse()smartAgent?.argueRent(500)smartAgent?.signAgreement() 看到这里就有人要问了，咦？之前不是用 by 关键字就可以在 kotlin 中进行代理吗？为啥还需要像 Java 一样用 Proxy.newProxyInstance() 方法写代理的模式？这两种方式有什么区别？ 首先，这两种方式都可以在 Kotlin 中实现代理模式，但适用的场景有所不同。1、by 关键字实现的代理模式。使用起来更加方便，代理的粒度更小，可以根据代理类自身需要对某些被代理类中的方法进行重写；2、Proxy.newProxyInstance() 方法实现的代理模式。实现比较繁琐，代理的粒度大，一旦代理，就是代理所有的方法。可以在原方法前后插入自己想要执行的代码，适用于埋点记录 log 日志、记录方法执行用时等。 参考文献 Java动态代理——框架中的应用场景和基本原理 当Kotlin邂逅设计模式之代理模式(二) ps. 赠人玫瑰，手留余香。欢迎转发分享，你的认可是我继续创作的精神源泉。 还没看够？来我的公众号看看？搜索： 俢之竹或者扫一扫下面的二维码： 来知乎逛逛也是可以的，搜索： 俢之竹]]></content>
      <tags>
        <tag>Android World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建个人博客网站]]></title>
    <url>%2F2021%2F06%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;拥有自己的博客网站是一件很酷的事情。拖了很久，终于在近期成功搭建了自己的博客网站。现记录下搭建博客的方法步骤，以备不时之需。&emsp;&emsp;先来看看效果（建议使用Chrome浏览器）： 修之竹的小院时光&emsp;&emsp;网上搭建博客网站的方法有很多，个人推荐使用 Hexo + Github 组合。不仅因为免费开源，而且有许多美观的主题可选，还可以学到许多技能，简直一举多得！ 啰嗦的简介Hexo&emsp;&emsp;这是一个快速、简洁且高效的博客框架。支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。只需一条指令即可部署到 GitHub Pages、Heroku 或其他网站。 GitHub&emsp;&emsp;GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 git 作为唯一的版本库格式进行托管，故名 GitHub (百度)。 正式开干Step1：安装 Git 和 Node.js&emsp;&emsp;Git 下载：https://git-scm.com/downloads 选择相应系统版本进行下载。本人所用电脑是 Windows 10，则下载 Git-2.19.1-64-bit.exe 即可。安装完成后打开 cmd ，输入下面命令查看是否安装成功：git --version若可查询出 git 版本号，则说明安装成功。&emsp;&emsp;Node.js 下载： https://nodejs.org/en/ 新手建议选择左边的 Recommend For Most Users 版本。同样，安装完成后打开 cmd ，输入下面命令查询是否安装成功：node -v都安装成功后进入下一步。 Step2：安装 Hexo&emsp;&emsp;首先，在自己的电脑上选择一个目录作为将要存放博客相关资料的文件夹。比如我自己选择的是 D 盘的 MyBlogs 目录，博客相关资料包括 Hexo 的配置文件、博客文档、使用的 Theme 主题文件等等。进入到你所选的文件夹中，点击鼠标右键，选择 Git Bash Here 打开 git 命令窗口，依次输入并执行下面命令：12345$ npm install hexo-cli -g //安装 hexo 扩展插件 $ hexo init blog //在所选文件夹中创建一个 blog 文件夹，并把 hexo 相关代码下载到这个文件夹中 $ cd blog //进入到 blog 目录 $ npm install //安装 hexo $ hexo server //启动本地服务 执行完上述命令后，显示器应该会提示说 Hexo 正在 http://localhost:4000 上运行：这个说明，hexo 在你的本地计算机上已经运行起来了，可以在你本地计算机上的浏览器中输入 http://localhost:4000 网址查看显示效果，如果显示如下，那就说明，本地服务启动成功！如果要关闭本地服务，则在 Git Bash 命令窗口中输入 Ctrl + COK ，目前本地我们可以访问了，接下来就要让其他人能访问你的博客网站了！ GitHub 要大显身手啦！ Step3：在 GitHub 上创建一个远程仓库&emsp;&emsp;如果还没有 GitHub 账号，墙裂推荐赶紧注册，注册好后往下走，如图。1、 点击右上角的 + 号创建一个仓库；2、 设置仓库名称，这里必须为 username.github.io , username 替换成你 GitHub 自己的用户名，比如说我这里就是要设置为JinchaoWen.github.io剩下的步骤不是很主要，详细可看图，完成之后点击 Create repository 创建仓库。创建成功后如图所示：这里有两个地址，一个是 Https ，一个是 SSH 。 Https 每次提交都需要输入用户名和密码，SSH 只要添加了 SSH key 值，以后提交就不需要输入用户名和密码。&emsp;&emsp;接下来要在 GitHub 中添加 SSH key 。首先检查本地是否已存在：12$ cd ~/.ssh //进入 .ssh 目录中$ ls //查看 .ssh 目录下的文件 如果本地有 SSH key ，则此时就会显示 id_rsa 、 id_rsa.pub 、 know_hosts 三个文件 。如果本地没有，再来创建 SSH key$ ssh-keygen -t rsa -C &quot;你自己的邮箱地址&quot;把 “你自己的邮箱地址” 替换成你真实的邮箱，然后点击回车。接着会让你输入文件名，点击回车直接忽略，接着会让输入两次密码，点击两次回车，直接设置为空，不用输入密码。创建成功后，可通过下面命令拷贝密钥：$ clip &lt; ~/.ssh/id_rsa.pub然后，进入个人 GitHub 页面，点击自己的头像，选择 Setting 进入设置页面，再点击 SSH and GPG keys ，进入后点击 New SSH key，输入 Title 为你的 SSH key 起个名，然后 Ctrl + V 粘贴刚复制的 key 值，最后点击 Add SSH key 按钮即可添加进来。可通过如下命令检查是否添加成功：$ ssh -T git@github.com如果显示信息中包含 You&#39;ve successfully authenticated 则说明添加成功！ Step4：配置博客主题修改网站设置&emsp;&emsp;在之前生成的 blog 目录下找到配置文件 _config.yml ，用 EditPlus 或记事本打开，修改 depoly 如下：1234deploy: type: git repo: git@github.com:username.github.io.git #username同上要换成你自己的用户名 branch: master 修改 site 信息：123title: #给自己的博客网站起个名字author: #当然也要写上自己的大名language: zh-Hans #设置博客网站的语言，在这里如果设置为 zh-Hans 不管用，可以换成 zh-CN 试试。 给博客网站换装在 GitHub 首页搜索 hexo theme ，可通过右边的过滤条件进行排序默认是按照项目的 star 数目进行排序筛选的，我们这里就选第一个了。仔细看项目的 ReadMe ，发现这个项目最新的版本已经迁移到这个网址了：https://github.com/theme-next/hexo-theme-next建议使用新的这个，找到 Installation 说明：12$ cd hexo$ git clone https://github.com/theme-next/hexo-theme-next themes/next 注意了，目前你的目录中并没有 hexo 目录，这是因为他把 blog 文件夹名称改成了 hexo ，你也可以改成其他的名称，最好的是英文，中文我没试过。这里的意思是，将这个主题文件从 GitHub 的远程仓库拷贝到你的 blog 目录下的 themes 目录中，拷贝完成之后检查会发现多了一个 next 目录，这里就是刚刚下载的主题文件。然后返回到 blog 目录下，修改 _config.yml 中的 theme ：theme : next这就可以将之前的默认主题 landscape 更换成 next 新主题。接下来就是修改主题的配置文件 _config.yml 。注意： next 主题的配置文件是 blog/themes/next/_config.yml 这个，并不是 blog 根目录下的 _config.yml 文件！修改 menu ：123456789menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 根据自己的需要去掉注释，也可参照上面的。修改 Schemes ：1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini next 主题给我们提供了上述四种风格： 选择哪种就将哪种的注释去掉，并将给其他的加上注释，上面就是选择了 Muse 风格。编辑主题配置文件，启用自动摘录：123auto_excerpt: enable: true length: 150 添加 LocalSearch 搜索功能：安装相关插件：1$ npm install hexo-generator-searchdb --save 在 next 目录中的 _config.yml 设置，启用本地搜索功能：123# Local searchlocal_search: enable: true 还可以添加一些博客网站的其他组件，具体的可以查看下面的他山之石中的第一篇：如何搭建个人博客 ？Hexo + GitHub 是一个不错的选择写的非常详细。快大功告成了，回到之前 blog 目录下，打开 Git Bash 命令窗口，运行$ hexo g命令生成静态文件，然后运行下面命令安装扩展插件：1$ npm install hexo-deployer-git --save 最后执行$ hexo d命令部署到远程仓库，部署成功后就可以通过访问 http://username.github.io 进入博客网站了（ username 替换成你自己的 GitHub 用户名）。 更上一层楼统计访客流量&emsp;&emsp;超级建议从一开始就将这个小小的插件运用到自己的博客网站中，可以看到自己博客网站的阅读量，也是一种精神上的支持。这里借用了 不蒜子 的统计插件。找到 X:\xxxxx\Hexo\themes\next\layout\_partials 路径下的 footer.swig 文件，用EditPlus或记事本打开，在最底部添加以下代码：12345678910&#123;% if theme.footer.counter %&#125; &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人&lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 有些博客中不蒜子插件并不是最新的，所以可能会失效，建议以不蒜子官方帖子为准。&emsp;&emsp;然后还要在next主题的设置文件中添加设置，就是这个文件： themes/next/_config.yml 找到footer字段，添加 counter:true ，如下所示：12footer: counter: true 到这里，可以保存一下，运行 hexo g 命令生成一下静态页面；然后运行 hexo s 命令启动本地服务器，在浏览器中输入 http://localhost:4000查看效果，如果显示不对，仔细检查修改，如还有问题，欢迎邮箱联系 `wenjinchao@outlook.com`。 多终端维护博客网站&emsp;&emsp;相信很多同学跟我一样，公司有一个本，自己有一个本，家里还有一个台式机，这么多设备能不能一起来维护自己的博客网站呢？git不就是这种思想吗？当然是可以的。&emsp;&emsp;首先在A电脑上按照上面的说明配置好了博客环境，以及可以正常发博客，拉取博客信息等。接下来，在A电脑的博客目录下打开Git Bash命令窗口，依次运行下面命令：1234git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:yourname/yourname.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上 执行完后，你自己的博客GitHub项目中就会多出一个hexo分支，这个分支就是用来作多终端同步的功能。&emsp;&emsp;B电脑这边一开始也要像A电脑一样配置一下node、git等环境，具体就是完成“正式开干”的step1和step2，在这里我遇到过下面的问题，没有遇到的同学请跳过。找度娘之后，运行 npm cache clean 命令清理npm之后就可以了，如果还不能清理，可用 npm cache clean --force 强制清理。为了让B电脑也能操作hexo分支，所以也要设置一下B电脑的SSH key，步骤可参考前文。&emsp;&emsp;前面的工作准备完毕后，就可以进入你想要存放博客文件的目录中依次执行下面的命令：12345678git clone -b hexo git@github.com:yourname/yourname.github.io.git //将Github中hexo分支clone到本地B电脑cd yourname.github.io //切换到刚刚clone的文件夹内npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再inithexo new post &quot;new blog name&quot; //新建一个.md文件，并编辑完成自己的博客内容git add source //经测试每次只要更新source中的文件到Github中即可，因为只是新建了一篇新博客git commit -m &quot;XX&quot;git push origin hexo //更新远程hexo分支hexo d -g //生成博客静态页面，并将资源上传同步到远程博客网站中 执行完之后，就会发现刚刚在B电脑上新建的文章就出现在网站上了。所有的文章都会保存在 \source\_posts 目录中，以后可以直接打开这些 .md MarkDown格式的文件进行文章编辑，建议下载 MarkdownPad 软件进行编辑，支持预览。&emsp;&emsp;小建议：在开始编写或修改文章，或者修改配置文件之前，一定要在本地 hexo 分支下先拉取一下远程的 hexo 分支，即执行命令1git pull origin hexo 然后进行修改，编辑完成之后，依次执行1234git add source //提交修改的内容git commit -m &quot;XX&quot; //添加commit信息git push origin hexo //将更新后的hexo推到远程的hexo分支hexo d -g //生成博客静态页面，并将资源上传同步到远程博客网站中 过一段时间，就可以访问自己的博客网站查看更新后的博客内容了。 他山之石1、如何搭建个人博客 ？Hexo + GitHub 是一个不错的选择2、网站访问量统计 | hexo3、如何解决github+Hexo的博客多终端同步问题4、hexo生成博文插入图片5、hexo博客图片问题]]></content>
      <tags>
        <tag>Setting Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的组件“活”起来！—— Lifecycle 浅析]]></title>
    <url>%2F2021%2F01%2F17%2FMake-Component-Alive-Lifecycle-Simple-study%2F</url>
    <content type="text"><![CDATA[Lifecycle 是 Android Jetpack 工具包中的一个工具库，Jetpack 中的工具可以分为四个部分：架构（Architecture）、基础（Foundation）、行为（Behavior）、界面（UI）。 其中，架构部分是 Jetpack 工具包的精华所在，大家耳熟能详的 DataBinding、LiveData、ViewModel等都是属于 Architecture 架构部分。Lifecycle 的地位就可想而知了。 1、背景众所周知，Activity 是有自己的生命周期的，从 onCreate 创建一直到 onDestroy 销毁，我们会在 Activity 的各个生命周期中做相应的处理，完成业务逻辑的开发工作。 比如，某些功能组件需要在 Activity 或者 Fragment 的某些生命周期函数中做一些初始化，资源回收等等操作。久而久之，Activity 中的代码体积就会变得臃肿，功能组件也与 Activity 耦合在一起了。 为了解决这个问题，google 就开发出了 Lifecycle 这个工具。 官方文档上有个例子，假如 Activity 中有一个定位的功能组件，如果没有使用 Lifecycle，大致的实现是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041// 1、开发自己的功能组件，实现相关功能class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // 连接系统定位服务 &#125; void stop() &#123; // 断开系统定位服务 &#125;&#125;// 2、在 Activity 中调用自己开发的功能组件，并在 Activity 生命周期中进行相应操作class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; // 初始化自己开发的功能组件 myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // 更新 UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // 管理其他需要响应 activity 生命周期的组件 &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // 管理其他需要响应 activity 生命周期的组件 &#125;&#125; 2、Lifecycle 的使用引入 Lifecycle 之后，我们就可以在定位组件的内部监听到 Activity 的生命周期的变化，从而执行相应的操作。不需要在 Activity 的各个生命周期方法中调用自身的业务逻辑方法，从而实现功能组件与 Activity 的相互隔离与解耦，降低 Activity 中的代码量。 大体的思想就是一个观察者模式，具有生命周期的 Activity、Fragment 等作为被观察者；需要在不同的生命周期中执行不同的业务逻辑的功能组件作为观察者，当观察者监听到生命周期发生变化时，执行相应的业务逻辑。具有生命周期的 Activity、Fragment 等，在下文中我们用 生命周期持有者（LifecycleOwner）来称呼；我们自己开发的需要依赖于生命周期的功能组件，在下文中用 生命周期观察者（LifecycleObserver）进行称呼。 2.1 引入依赖如果是非 AndroidX 项目，则引入：1implementation &quot;android.arch.lifecycle:extensions:1.1.1&quot; 如果是 AndroidX 项目，则引入：1implementation &apos;androidx.appcompat:appcompat:1.2.0&apos; 如果只需要使用 Lifecycle，不需要其他的 ViewModel、LiveData等等的话，则只需要引入 lifecycle-runtime 包即可。 2.2 实现 Lifecycle 观察者这个 Lifecycle 观察者就是我们自己开发的功能组件，加上 LifecycleObserver 接口就可以通过注解的方式来编码各个生命周期需要执行的业务逻辑。如代码所示：123456789101112131415161718192021222324252627class MyLocationListener implements LifecycleObserver &#123; MyLocationListener(Activity activity, OnLocationChangedListener onLocationChangedListener) &#123; // 初始化 initLocationManager(); &#125; // 当 Activity 执行 onResume 方法时，自动调用该方法 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) private void startGetLocation()&#123; Log.i(TAG, &quot;startGetLocation() is executed&quot;); &#125; // 当 Activity 执行 onPause 方法时，自动调用该方法 @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) private void stopGetLocation()&#123; Log.i(TAG, &quot;stopGetLocation() is executed&quot;); &#125; private void initLocationManager()&#123; Log.i(TAG, &quot;initLocationManager() is executed&quot;); &#125; // 当位置发生变化时，通过该接口通知调用方 public interface OnLocationChangedListener&#123; void onChange(double latitude, double longitude); &#125;&#125; 2.3 生命周期持有者添加观察者在 Android 中具有生命周期的一般是 Activity、Fragment，先通过 getLifecycle 方法获得 Lifecycle 生命周期对象，Lifecycle 对象使用 addObserver 方法给自己添加观察者，即 MyLocationListener。这样一来，当 Lifecycle 生命周期发生变化，MyLocationListener 就会收到通知，做相应的操作。12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MyLocationListener myLocationListener = new MyLocationListener(this, new MyLocationListener.OnLocationChangedListener() &#123; @Override public void onChange(double latitude, double longitude) &#123; // 位置发生变化时，调用该方法 &#125; &#125;); // 将观察者（MyLocationListener）与被观察者（MainActivity）绑定 getLifecycle().addObserver(myLocationListener); &#125;&#125; 那么，这种观察者模式是怎样建立起来的呢？我们可以去看看 Jetpack 中 Lifecycle 相关源码。 3、Lifecycle 源码浅析下面的源码分析是基于 lifecycle-runtime:2.1.0、lifecycle-common:2.1.0 版本。从 getLifecycle() 方法进入，发现是来到了 ComponentActivity 中，ComponentActivity 就是 Activity 的基类，代码如下：123456// ComponentActivity.java 类@NonNull@Overridepublic Lifecycle getLifecycle() &#123; return mLifecycleRegistry;&#125; 还可以看出，其实 ComponentActivity 只是实现了 LifecycleOwner 这个接口：12345678910111213141516171819// LifecycleOwner.java 接口文件public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125;// ComponentActivity 实现了 LifecycleOwner 接口public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, SavedStateRegistryOwner, OnBackPressedDispatcherOwner &#123; ···&#125; 回过头来再看看 ComponentActivity 中的 getLifecycle 方法，返回了一个 Lifecycle 对象，这个对象是在 ComponentActivity 中 new 出来的，并将 Activity 实例传参给了它：1private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); LifecycleRegistry 类是一个 Lifecycle 的实现类，Lifecycle 本身只是一个抽象类，里面定义了一些生命周期中的状态 State 以及切换生命周期的一些事件 Event，还有一些抽象方法：12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Lifecycle &#123; ... // 添加生命周期观察者 抽象方法 @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); // 移除生命周期观察者 抽象方法 @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); // 获取当前生命周期状态 抽象方法 @MainThread @NonNull public abstract State getCurrentState(); // 定义的事件值，对应 Activity 的各个生命周期发生事件 @SuppressWarnings(&quot;WeakerAccess&quot;) public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY // 可以响应任何一个事件 &#125; // 生命周期状态值 @SuppressWarnings(&quot;WeakerAccess&quot;) public enum State &#123; DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; /** * Compares if this State is greater or equal to the given &#123;@code state&#125;. * * @param state State to compare with * @return true if this State is greater or equal to the given &#123;@code state&#125; */ public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125;&#125; 再来看看 LifecycleRegistry 类具体实现了 Lifecycle 中的哪些方法。 3.1 LifecycleRegistry 类具体实现首先，它内部是用一个类似 Map 的数据结构来存储添加的生命周期观察者的：12private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;(); Key 是将要存储的观察者，Value 是将这个观察者赋予一个 State 状态，然后存到 Value 中，看它们的命名也可以理解。这个数据结构是为了管理所有的观察者，方便添加和移除。 先看看添加观察者的 addObserver 方法在 LifecycleRegistry 类的具体实现 ：123456789101112131415161718192021222324252627282930313233343536373839// LifecycleRegistry.java 类@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; // 根据 LifecycleOwner 的生命周期状态 mState 初始化一个 状态赋给 将添加的观察者 State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; // 不为空 说明 observer 之前已添加过，则返回不再处理 &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); // 获取的是 LifecycleOwner 的一个弱引用，如果 为空则说明被回收了，就不往下执行了 if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; // 是否重入 判断，如果正在添加的观察者不为0 或 正在处理 Event 事件，则发生了重入 boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); // 计算出目标状态 mAddingObserverCounter++; // while 循环里处理的事情就是，避免 该 observer 因为添加的晚，使得一些生命周期流转分发事件 // 没有被分发给 该 observer。有点像 粘性广播 的意思 while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); // 同步所有观察者状态，后面会细说 &#125; mAddingObserverCounter--;&#125; 代码注释的比较清楚了。这里补充说明下 calculateTargetState 方法是如何计算出新添加的 LifecycleObserver 的目标状态 State 的，可以看一下它的代码：12345678910private State calculateTargetState(LifecycleObserver observer) &#123; // 首先获取 前一个添加的观察者 previous Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); // previous 不为空时，获得 previous 的状态值赋给 siblingState State siblingState = previous != null ? previous.getValue().mState : null; // mParentStates 列表不为空时，将最近添加的 state 值赋给 parentState State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; return min(min(mState, siblingState), parentState);&#125; 它是取 mState、parentState、siblingState 中的最小值作为自己的 targetState。然后需要将自己的状态一步步切换到 targetState，如何进行的，后面会细说。 再来看看 LifecycleRegistry 类的实例化。 new 一个 LifecycleRegistry 类时，会将 LifecycleOwner 的弱引用传进去，并将 state 初始化为 INITIALIZED。1234public LifecycleRegistry(@NonNull LifecycleOwner provider) &#123; mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; &#125; 因为 LifecycleOwner 一般是 Activity、Fragment，所以用弱引用持有它们可以防止内存泄漏。 从 Lifecycle 抽象类中定义的状态枚举类型和事件枚举类型就可以看出，生命周期状态的流转，都是通过执行这些事件 Event 串起来的。比如说，ON_CREATE 事件发生后，生命周期状态就会从 INITIALIZED 流转到 CREATED 状态。生命周期状态的流转是通过 handleLifecycleEvent 这个方法实现的。12345// 处理生命周期转换事件public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); // 首先求出 执行 event 事件之后的生命周期 状态值 state moveToState(next); // 然后将 state 设置为 新的生命周期状态&#125; 在 getStateAfter 方法中，求出在执行了 event 事件之后，生命周期的状态。具体的代码很简单：1234567891011121314151617static State getStateAfter(Event event) &#123; switch (event) &#123; case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; &#125; throw new IllegalArgumentException(&quot;Unexpected event value &quot; + event); &#125; 看代码可能会觉得纳闷，为啥 ON_STOP 事件之后进入 CREATED 状态？我理解的是官方考虑到 CREATED 和 停止状态（STOPPED）可以合并为同一个状态，CREATED 状态其实就是 STARTED 状态前的一种状态，也就是 停止状态（STOPPED）。可以参考官方文档的这张图帮助理解： 所以，一个完整的生命周期过程是：从 Initialized 开始，到 Resumed；再从 Resumed 到 Destroyed 结束。在图上就是从左到右，再从右到左。 拿到下一个状态值后，再调用 moveToState 方法将生命周期持有者的状态切换到新的状态值。123456789101112131415private void moveToState(State next) &#123; if (mState == next) &#123; // 如果已接切换完成，则跳过 return; &#125; mState = next; // 状态重置为新的值 if (mHandlingEvent || mAddingObserverCounter != 0) &#123; // 如果上一次状态切换还未完成(mHandlingEvent = true)，或者存在正在添加中的观察者 mNewEventOccurred = true; // 出现新的状态值 // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; // 正在处理状态切换 标记位 sync(); // 将新的生命周期状态同步给所有的观察者 mHandlingEvent = false; &#125; 将自身的生命周期状态更新后，还得将新的状态同步给所有的观察者，这就是 sync 方法需要处理的。12345678910111213141516171819202122232425262728293031323334// 同步生命周期状态方法private void sync() &#123; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); // 由于之前为了防止内存泄漏，将 LifecycleOwner 包装成了一个弱引用，所以这里需要检查一下是否被回收了 if (lifecycleOwner == null) &#123; throw new IllegalStateException(&quot;LifecycleOwner of this LifecycleRegistry is already&quot; + &quot;garbage collected. It is too late to change lifecycle state.&quot;); &#125; while (!isSynced()) &#123; mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us. if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) &#123; backwardPass(lifecycleOwner); &#125; Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest(); if (!mNewEventOccurred &amp;&amp; newest != null &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) &#123; forwardPass(lifecycleOwner); &#125; &#125; mNewEventOccurred = false;&#125;...// 判断是否已经同步完成private boolean isSynced() &#123; // 如果没有生命周期观察者了，那肯定就不用同步了 if (mObserverMap.size() == 0) &#123; return true; &#125; State eldestObserverState = mObserverMap.eldest().getValue().mState; State newestObserverState = mObserverMap.newest().getValue().mState; return eldestObserverState == newestObserverState &amp;&amp; mState == newestObserverState;&#125; 先来看看它是怎么判断已经同步完成的。在 isSynced 方法中，获取所有观察者中最先添加和最近添加的观察者的生命周期状态值，当这两者的状态值都与当前生命周期持有者的状态值（mState）相同，就说明同步完成了。 再来看看 sync 同步方法，有一个 while 循环，当还未同步完成时，会先判断当前状态是否在最先添加的观察者的状态值的前面（mState &lt; eldest().getValue().mState），如果是，则调用 backwardPass 方法。123456789101112131415private void backwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); observer.dispatchEvent(lifecycleOwner, event); popParentState(); &#125; &#125;&#125; 在 backwardPass 方法中，首先初始化了一个 递减迭代器，即这个迭代器是从最近添加的观察者开始遍历，一直遍历到最初添加的观察者（之所以这样的遍历顺序是递减迭代器，是因为越在前面添加的观察者，它的 state 越小，这里的递减是指 state 是递减的顺序），要完成所有观察者的状态的更改，这是第一层的 while 循环。如果这个时候又有新的 Event 事件发生，则中止同步过程，节省系统资源，因为这个时候可能会产生新的状态值。 第二层循环开始前，再次确认观察者状态值比当前状态值要大，且没有新的 Event 出现，以及该观察者没有被移除。然后调用 downEvent 方法根据观察者现在的状态，得到 Event 事件：12345678910111213141516// 降低 state 值的方法private static Event downEvent(State state) &#123; switch (state) &#123; case INITIALIZED: throw new IllegalArgumentException(); case CREATED: return ON_DESTROY; case STARTED: return ON_STOP; case RESUMED: return ON_PAUSE; case DESTROYED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(&quot;Unexpected state value &quot; + state);&#125; 仔细看 downEvent 方法中的每个状态对应的返回事件，结合之前的状态事件流程图图1，可以发现 downEvent 方法处理的是 state 状态后接下来发生的 event，对应图1 中从右向左的过程，不考虑向左的事件流程。这样做就可以将观察者的 state 逐渐减小，直至与当前生命周期持有者的状态值（mState）相同。如图2所示： 对应地，还有个 upEvent 方法，这个方法会不会就是处理图1 中从左到右的过程呢？查看代码，果然如此：123456789101112131415// 升高 state 值的方法private static Event upEvent(State state) &#123; switch (state) &#123; case INITIALIZED: case DESTROYED: return ON_CREATE; case CREATED: return ON_START; case STARTED: return ON_RESUME; case RESUMED: throw new IllegalArgumentException(); &#125; throw new IllegalArgumentException(&quot;Unexpected state value &quot; + state);&#125; 例如 CREATED 状态向右的 Event 就是 ON_START，而 RESUMED 没有向右的事件，所以就向外抛出异常。 再来看 downEvent 方法之后，调用了 pushParentState 方法，这个方法就是记录了该观察者下一个状态，等到观察者分发了 Event 事件之后，再把这个状态记录删除掉，也就是后面的 popParentState 方法。重点就是中间的这个 dispatchEvent 分发事件的方法。这个方法是由该观察者调用的，将之前调用 downEvent 方法得到的 event 事件分发出去，具体的代码如下：123456void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState;&#125; 这个方法是属于观察者内部类，里面的 mState 并不是生命周期持有者的当前状态，而是这个观察者的当前状态，所以方法的最后把这个值更新为新的状态值了。在更新之前还调用了 onStateChanged 方法，这个方法是 LifecycleEventObserver 接口中的方法，而 LifecycleEventObserver 是继承自 LifecycleObserver，在 LifecycleEventObserver 的注释中有这样一句： If a class implements this interface and in the same time uses {@link OnLifecycleEvent}, then annotations will be ignored. 翻译过来就是，如果一个类实现了这个接口，同时也使用了{@link OnLifecycleEvent}（即使用 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)），那么后者的 annotation 注解的方法就不会被执行。也就是说，各个生命周期中执行的相应操作，都是在这里的 onStateChanged 方法中执行的。接口方法具体的实现交给了开发者，也就是被 @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) 等等标记的方法。 到这里终于可以总结一下生命周期持有者 LifecycleOwner 是如何处理生命周期事件的了。LifecycleOwner 通过执行 handleLifecycleEvent 方法，处理收到的生命周期事件 Event。首先，根据 Event 得到下一个生命周期状态，将自身状态更新；然后，将状态的变动同步给所有观察它的观察者；观察者们用自己的状态与 LifecycleOwner 的状态做比对，逐步算出要达到与 LifecycleOwner 状态一致所需的 event 事件，并逐步将这些 event 分发出去；这样，观察者内部就可以接收到这些 event，并可以根据不同的 event 做不同的业务操作了。 回头再看一下 sync 方法，在 backwardPass 方法执行完后，接下来会获取最近添加的观察者。当 LifecycleOwner 的当前状态比最近添加的观察者的状态值要大，那么就会调用 forwardPass 方法：1234567891011121314private void forwardPass(LifecycleOwner lifecycleOwner) &#123; Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123; Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) &lt; 0 &amp;&amp; !mNewEventOccurred &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123; pushParentState(observer.mState); observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); &#125; &#125;&#125; 与 backwardPass 方法相反，forwardPass 方法是通过一个递增迭代器，从最初添加的观察者开始一直遍历到最近添加的观察者，依次更改所有观察者的状态。第一层 while 循环就是遍历所有的观察者；第二层 while 循环里就是将每个观察者的状态逐步地更新成与 LifecycleOwner 的状态 mState 一样，并将 event 事件分发。 3.2 ReportFragment 类简述前文终于弄清楚了生命周期状态的更新与分发过程。再来看一看是在哪里调用 handleLifecycleEvent 方法开始处理生命周期事件的，如下图所示。 Fragment 有自己的生命周期，所以它里面肯定会调用 handleLifecycleEvent 方法。 FragmentActivity 里面调用 handleLifecycleEvent 方法的对象，并不是 Activity 的 Lifecycle 对象，而是 Fragment 的 Lifecycle 对象，管理的是 Fragment 生命周期流转，从命名 mFragmentLifecycleRegistry 也可以看出来。 FragmentViewLifecycleOwner 是单独用来管理 Fragment 中 onCreateView 和 onDestroyView 的生命周期的管理类。所以，我们也可以自己扩展新的生命周期。 ProcessLifecycleOwner 管理整个 Application 的生命周期，需要另外引入 androidx.lifecycle:lifecycle-process 库。借助这个库，我们可以直接获取到应用前后台切换的状态，以及应用的整个生命周期。需要注意的是，Lifecycle.Event.ON_CREATE 只会分发一次，Lifecycle.Event.ON_DESTROY 不会被分发。 ReportFragment 是 Activity 中真正管理各种生命周期分发的类。 ServiceLifecycleDispatcher 管理 Service 生命周期分发的帮助类。如果需要在 Service 中使用 Lifecycle，需要自己的 Service 继承自 LifecycleService，并且加入 androidx.lifecycle:lifecycle-service 依赖。 ReportFragment，专门用来分发生命周期 Event 事件的 Fragment，没有可视化界面。最初见于 ComponentActivity 的 onCreate 方法中：12345678protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSavedStateRegistryController.performRestore(savedInstanceState); ReportFragment.injectIfNeededIn(this); // ReportFragment 初始化 if (mContentLayoutId != 0) &#123; setContentView(mContentLayoutId); &#125;&#125; 在 injectIfNeededIn 方法里初始化了这个 Fragment，用的还是 framework 里的 Fragment，原因注释里也说的很清楚，因为考虑到有些 Activity 并不是继承自 FragmentActivity。在 ProcessLifecycleOwner 中也是用到这个方法初始化 ReportFragment，而 ProcessLifecycleOwner 是 Application 的生命周期持有者。12345678910public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125;&#125; 可以看到，在这个 Fragment 生命周期方法中，都是调用 dispatch 方法分发Event 事件的。由于 ReportFragment 是挂靠在 ComponentActivity 上的，所以 ComponentActivity 的生命周期与 ReportFragment 的生命周期是关联在一起的。所以，ReportFragment 就可以准确分发 ComponentActivity 的生命周期事件。在 dispatch 方法中，就是调用的上面所说的 LifecycleRegistry 类的 handleLifecycleEvent 方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344···@Overridepublic void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE);&#125;@Overridepublic void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START);&#125;@Overridepublic void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME);&#125;@Overridepublic void onPause() &#123; super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE);&#125;···// 分发 Lifecycle.Event 的方法private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; // LifecycleRegistryOwner 已废弃，这一段可以不看 ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; // 最终还是调用的 LifecycleRegistry 中的 handleLifecycleEvent 方法 ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 除此之外，ReportFragment 还负责了 Application 的生命周期的事件分发：12345678910111213141516171819202122232425262728293031323334353637// ReportFragment 中的部分代码 注：仅节选了相关的代码private ActivityInitializationListener mProcessListener;void setProcessListener(ActivityInitializationListener processListener) &#123; mProcessListener = processListener;&#125;interface ActivityInitializationListener &#123; void onCreate(); void onStart(); void onResume();&#125;// ProcessLifecycleOwner.java Application 的生命周期持有者void attach(Context context) &#123; mHandler = new Handler(); mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); Application app = (Application) context.getApplicationContext(); app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; ReportFragment.get(activity).setProcessListener(mInitializationListener); &#125; @Override public void onActivityPaused(Activity activity) &#123; activityPaused(); &#125; @Override public void onActivityStopped(Activity activity) &#123; activityStopped(); &#125; &#125;);&#125; 这里不再展开了，只需要知道，Application 的生命周期持有者 ProcessLifecycleOwner 也是使用 ReportFragment 进行生命周期状态分布就可以了。 综上，可以看出，ReportFragment 和 LifecycleRegistry 是 Lifecycle 最重要的两个类。理解了它们，Lifecycle 的整体流程和思想就比较清楚了。其实 Lifecycle 内容远不止这些，代码也在不断地迭代中，本文只是起到抛砖引玉作用，更多内容可查看源码~ 写的不错？点赞吧！你的鼓励，是我继续创作的最大动力！！！ ps. 一个简单的 Demo：https://gitee.com/xiuzhizhu/LifeCycleDemo 参考文献1、Android Lifecycle 官方文档2、https://juejin.cn/post/6893870636733890574#heading-133、https://juejin.cn/post/6850418115931537416]]></content>
      <tags>
        <tag>Android World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 组件化实践]]></title>
    <url>%2F2020%2F04%2F06%2FAndroid-Component-Practice%2F</url>
    <content type="text"><![CDATA[引子一般情况下，一个 Android 项目，随着业务的发展和扩张，会有许多 Activity、Fragment 等文件，如果没有一个好的架构，整个项目将会变得非常混乱，如下图图1所示。最直观的感受就是文件巨多所导致的人工手动搜索时长耗时严重。。。长此以往更会拖慢整个项目的编译速度，甚至是修改一个 Java 代码中的数字就要编译个七八分钟。 为了解决上述的这些问题，我们可以将 App 进行拆分，组件化实现。其实大公司的 App 基本上都是这种类似的架构，比如美团 App、知乎 App 等，整体的项目是一个 App 的空壳，而几个大的业务线均抽离出来形成几个互相独立的模块。 目的我们要进行组件化的目的，就是要降低模块间的耦合度，从而更好的进行维护，加快编译速度，提高开发效率。模块相比于组件，模块的体量更大，更偏向于业务；而组件颗粒度更小，且更偏向于功能。不同的业务模块可以用相同的组件进行实现，项目的开发人员较多的话，也方便根据组件来划分工作职责。 一个好的架构设计如图 2 所示。可以看到，Main App 差不多就是一个空壳，里面是由许多组件 Module A、Module B······所组成的业务模块构成的。Base Library 的作用就是为了实现各个 Module 之间的解耦。它是用这个 interface 来实现解耦的。比如 Module A 中的有个 loginActivity 要跳转到 Module B 中的 homeActivity，最初的做法有两种：一种是 Intent 显示跳转，这种方法要在 loginActivity 中实例化 homeActivity，耦合性太强。12Intent intent = new Intent( loginActivity.this, homeActivity.class );startActivity(intent); 另一种是 Intent 隐式跳转，要在 AndroidManifest 文件里配置，也不是很好。而图 2 中的设计，就是让 BaseLibrary 专门来负责组件之间的通信，各个组件通过实现它里面的 interface 来实现组件之间的相互解耦。 正式开干1、准备工作首先当然是新建一个主项目，然后，依次点击 File - New - Module - Phone &amp; Tablet Module，创建一个组件，我这里创建了三个组件，findcomponent 和 minecomponent、searchcomponent. 创建完之后如图 3 所示。从图中也可以看出，一个 Module 的文件目录很像一个完整的项目，其实此时它们是可以分别单独部署运行的。如图 4 所示，我们可以自行选择要执行哪一个组件。它们此时是相互独立的，分别部署到手机上也是几个不同的 App。为了演示方便，各个组件中创建的 Activity 以及布局文件均十分简单。 2、配置 gradle.properties 文件如何将这些组件集成到主 App 上，同时又可以单独运行呢？第一步，要配置一下 gradle.properties 文件。1234# 配置某个组件是否可独立运行findRunAlone = truemineRunAlone = truesearchRunAlone = true 这三行代码是初始化三个标记位，用来设置三个组件是否集成到主 App 中，设置为 true 则可独立运行；false 则作为主 App 的 library 运行。当然上述只配置了一半，还要在各个组件的 gradle 文件中作相应的修改：123456789if(searchRunAlone.toBoolean())&#123; apply plugin: &apos;com.android.application&apos;&#125;else&#123; apply plugin: &apos;com.android.library&apos;&#125;if(searchRunAlone.toBoolean())&#123; // 独立运行时需要设置 applicationId applicationId &quot;com.example.wen.searchcomponent&quot;&#125; 这里只拿 searchComponent 组件进行演示。在 gradle.properties 文件中，还可以将整个项目中所用的 SDK 版本、依赖库的版本进行声明，统一各个组件所用的 SDK 版本及各种依赖库的版本。例如，在此 gradle.properties 文件中添加以下代码：123456789101112# 全局配置 gradle 环境compile_sdk_version = 28min_sdk_version = 23target_sdk_version = 28# 配置其他依赖库android_support_appcompat_v7 = com.android.support:appcompat-v7:28.0.0android_support_constraint_layout = com.android.support.constraint:constraint-layout:1.1.3junit = junit:junit:4.12android_support_test_runner = com.android.support.test:runner:1.0.2android_support_test_espresso_core = com.android.support.test.espresso:espresso-core:3.0.2android_support_support_v4 = com.android.support:support-v4:28.0.0 这样初始化声明以后，就可以在各个组件中引用，达到统一版本，避免各个组件所用库版本不一致而收到的影响。比如在 searchComponent 组件中 gradle 文件中，我们就可以这样设置：1234567891011121314151617181920// 设置 sdk versioncompileSdkVersion compile_sdk_version.toInteger() defaultConfig &#123; if(searchRunAlone.toBoolean())&#123; applicationId &quot;com.example.wen.searchcomponent&quot; &#125; minSdkVersion min_sdk_version.toInteger() targetSdkVersion target_sdk_version.toInteger() &#125;// 引用主 APP gradle.properties 文件中的声明来设置各个依赖库的版本dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation android_support_appcompat_v7 implementation android_support_constraint_layout testImplementation junit androidTestImplementation android_support_test_runner androidTestImplementation android_support_test_espresso_core&#125; 3、配置 AndroidManifest.xml 文件Library 与 Application 的区别不仅仅体现在 gradle.properties 中，而且还体现在 AndroidManifest 文件中。所以组件在切换 Library 与 Application 时也要切换不同的 AndroidManifest 文件。首先在 gradle 中进行设置：12345678910sourceSets&#123; main&#123; // 独立运行与集成调试时使用不同的 AndroidManifest.xml 文件 if( searchRunAlone.toBoolean() )&#123; manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; &#125;else&#123; manifest.srcFile &apos;src/main/manifest/AndroidManifest.xml&apos; &#125; &#125; &#125; 即当组件是作为 Application 运行时，所用的 AndroidManifest 文件就是 main 目录下的，即之前 IDE 自己生成的；当组件是作为 Library 运行时，所用的就是 main/manifest 目录下的。所以我们要在 main 目录下创建一个 manifest 目录，并新建一个 AndroidManifest 文件，只需要将 Library 中必需的属性加上即可：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.wen.searchcomponent&quot;&gt; &lt;!-- 组件中有 searchActivity 故加入进去 --&gt; &lt;application&gt; &lt;activity android:name=&quot;.searchActivity&quot;&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 4、创建 BaseLibrary 实现组件解耦通过上述步骤，我们就创建了一个组件，重复上述步骤多创建几个不同的组件。接下来就是创建这些组件之间的“桥梁”，图 3 中出现的 componentlib 包其实就是那座“桥”，也就是 BaseLibrary. 用于组件之间的通信，从而实现解耦，阿里的 ARouter 也是类似的作用（自己还没有了解，这里引用老师所说的，欢迎拍砖指教）。 首先要把之前创建的组件切换成 Library ，即1234# 配置某个组件是否可独立运行findRunAlone = falsemineRunAlone = falsesearchRunAlone = false 然后在 app 中的 gradle 文件中将这些组件引用到主项目中，当然是在各个组件作为依赖的情况下：123456789if (!findRunAlone.toBoolean()) &#123; implementation project(&apos;:findcomponent&apos;)&#125;if (!mineRunAlone.toBoolean()) &#123; implementation project(&apos;:minecomponent&apos;)&#125;if(!searchRunAlone.toBoolean())&#123; implementation project(&apos;:searchcomponent&apos;)&#125; 接下来，依次打开 File - New - Module - Android Library 来创建一个 Library，取名为ComponentLib. 接下来就是配置项目结构，即各个组件与主 APP 之间的依赖关系。打开 Project Structure，在 Module 中可以看到已经创建的几个模块，包括 app、componentlib、searchcomponent 等。根据图 2 的整体架构图，app 是要添加所有的组件作为它的依赖库的，所以依次选择 Dependencies - 左下角 + 号 - Module Dependency，将组件全部添加进去，如图 5 所示；同样地操作，SearchComponent 等组件均要添加 componentlib 作为基础依赖。 注意： 如果在你打开的 Project Structure 并不是上图的形式，可能是 AndroidStudio 版本不同，比如在 AndroidStudio 3.6 以上的版本，不用配置这个项目结构，直接在 gradle implemention project 就可以了。 从图 2 中也可以看出，BaseLibrary 主要是通过 interface 这个接口来实现解耦的，那么接下来就是在 componentLib 中创建 interface 接口，并在相应的组件中实现这个接口了。 1）创建 BaseLibrary 的 interface 接口在 BaseLibrary 中创建 SearchComponent 的接口：1234public interface ISearchService &#123; void launch(Context context, String targetClass); Fragment newSearchFragment(FragmentManager fragmentManager, int viewId, Bundle bundle);&#125; 接口中写明要在 SearchComponent 组件中实现的方法，用于一些操作。第一个方法就是调用组件中 Activity 的方法；第二个方法是调用组件中的 Fragment 的方法。 2）组件实现 BaseLibrary 中的 interface 接口回到 SearchComponent 组件，创建一个 SearchService 类实现 ISearchService 接口，123456789101112131415public class SearchService implements ISearchService &#123; @Override public void launch(Context context, String targetClass) &#123; Intent intent = new Intent(context, searchActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; @Override public Fragment newSearchFragment(FragmentManager fragmentManager, int viewId, Bundle bundle) &#123; SearchFragment searchFragment = new SearchFragment(); searchFragment.setArguments(bundle); fragmentManager.beginTransaction().add(viewId,searchFragment).commit(); return searchFragment; &#125;&#125; 这里就写这两个函数举例，一个是启动这个 Activity；另一个是实例化一个 fragment。如何调用这两个函数，还要到 ComponentLib 进行相关的配置。 ####3）BaseLibrary 实现调用方法管理类OK, 现在每个组件中都有实现了调用该组件的 service 类了，为了解耦，这些类当然不能由组件自己调用，而是统一交给 BaseLibrary( ComponentLib )进行管理，所以我们要在 ComponentLib 中新建一个 ServiceFactory 类管理各个组件中的 service 类。12345678910111213141516171819202122232425262728293031323334353637383940414243public class ServiceFactory &#123; private static final ServiceFactory instance = new ServiceFactory(); public static ServiceFactory getInstance()&#123; return instance; &#125; private IFindService mFindService; private IMineService mMineService; private ISearchService mSearchService; public ISearchService getmSearchService() &#123; if(mSearchService == null)&#123; mSearchService = new EmptySearchService(); &#125; return mSearchService; &#125; public void setmSearchService(ISearchService mSearchService) &#123; this.mSearchService = mSearchService; &#125; public IFindService getmFindService() &#123; if(mFindService == null)&#123; mFindService = new EmptyFindService(); &#125; return mFindService; &#125; public void setmFindService(IFindService mFindService) &#123; this.mFindService = mFindService; &#125; public IMineService getmMineService() &#123; if(mMineService == null)&#123; mMineService = new EmptyMineService(); &#125; return mMineService; &#125; public void setmMineService(IMineService mMineService) &#123; this.mMineService = mMineService; &#125;&#125; 首先要创建一个 ServiceFactory 的单例，在我们的例子中有三个组件，所以这里创建了三个不同的 service 类，并加上它们的 get 和 set 方法，这里出现的 Empty***Service 类是为了提高程序的健壮性，后面会继续说。 ####4）项目 Application 管理组件化设计架构中，必然会牵扯到 Application 管理的问题，主 app 中的 Application 倒是没有什么问题，但要保证各个组件既能独立于主 app 运行，又能作为 Library 支持主 app 的运行，它们的 Application 就要进行相应地管理了。就是说，当组件独立运行时，使用自己的 Application；当组件非独立运行时，使用主 app 的Application，这就需要先在各个组件中创建类进行管理或者说切换。在 SearchComponent 中我们创建一个 SearchApplication 类：123456789101112public class SearchApplication extends Application &#123; private static Application application; public static Application getApplication()&#123; return application; &#125; @Override public void onCreate() &#123; // 如果 SearchComponent 是个 Application 时，会调用这个方法 super.onCreate(); &#125;&#125; 怎样才能获取到 主 App 中的 Application 呢？在这里我们还要创建一个主 App 中的 Application，在 app 目录中添加如下的 MainApplication 类：123456789101112public class MainApplication extends Application &#123; private static Application application; public static Application getApplication()&#123; return application; &#125; @Override public void onCreate() &#123; super.onCreate(); initialize(this); // 暂未实现该方法 &#125;&#125; 还要修改下 主 App 中的 AndroidManifest 文件，使得启动时运行这个 MainApplication 类，通过 onCreate 方法中的 initialize 方法将 主 App 中的 application 对象传递到各个不同的组件中。123&lt;application android:name=&quot;.MainApplication&quot;&lt;/application&gt; 接下来还有几步操作，第一步，就是在 componentlib/service 目录下，新建一个用于初始化的接口：123public interface IComponentApp &#123; void initialize(Application application);&#125; 所有的 Component 组件都要实现这个接口，用于获取到 主 App 中的 Application 对象。第二步，就是在刚才的目录下，再新建如下的一个类：1234567public class AppConfig &#123; public static final String[] COMPONENTS = &#123; &quot;com.daojia.wen.findcomponent.FindApplication&quot;, &quot;com.daojia.wen.minecomponent.MineApplication&quot;, &quot;com.daojia.wen.searchcomponent.SearchService&quot; &#125;;&#125; 这个类中存储的是各个 Component 组件的 Application 类的路径。 第三步，回到 MainApplication 类中，实例化 IComponentApp 接口：1234567891011121314151617181920212223242526public class MainApplication extends Application implements IComponentApp &#123; private static Application application; public static Application getApplication()&#123; return application; &#125; @Override public void initialize(Application application) &#123; for(String component: AppConfig.COMPONENTS)&#123; try&#123; // 通过配置文件中的 Application 的路径，实例化，并将 MainApp 的 Application 对象传过去 Class&lt;?&gt; clazz = Class.forName(component); Object object = clazz.newInstance(); if(object instanceof IComponentApp)&#123; ((IComponentApp)object).initialize(this); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); initialize(this); &#125;&#125; 从这个实例化的接口可以看出，在 MainApplication 类中，初始化的时候，是通过反射来实例化各个 Component 组件的 Application，并将 主 App 中的 Application 对象传过去作为各个组件的 Application。 第四步，在各个 Component 组件中实现 IComponentApp 接口，这里还是以 SearchComponent 组件为例：12345678910111213141516public class SearchApplication extends Application implements IComponentApp &#123; private static Application application; @Override public void initialize(Application app) &#123; application = app; ServiceFactory.getInstance().setmSearchService(new SearchService()); &#125; public static Application getApplication()&#123; return application; &#125; @Override public void onCreate() &#123; super.onCreate(); initialize(this); &#125;&#125; 在组件中，如果该组件被设置为独立运行，则会调用 onCreate() 方法，这时获取到的是它自己的 Application 对象；如果被设置为组件依赖于 主 App 运行，则会在 MainApplication 类中通过反射被实例化，获取到的是 主 App 中的 Application 对象。 到这里有没有发现，我在 initialize 方法中不仅仅将主 App 中的 Application 对象传递进来了，同时我还设置了 SearchService 实例，这个 Service 实例就可以在主 App 中调用 SearchComponent 中的方法了： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btn_go_search).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 去“查找”组件 ServiceFactory.getInstance().getmSearchService().launch(MainActivity.this,&quot;&quot;); } }); findViewById(R.id.btn_showSearchUI).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 去&quot;查找&quot;组件中的 UI 页面 Bundle bundle = new Bundle(); ServiceFactory.getInstance().getmSearchService().newSearchFragment(getSupportFragmentManager(), R.id.container,bundle); } }); } } OK，到这里基本上就已经完成了，再回过头来看一看 Empty***Service 类存在的必要性，上文已经说了，是为了提高程序的健壮性，为什么呢？这是为了考虑可能出现的空指针问题。 假如我们在之后要去掉 SearchComponent，如果没有写 EmptySearchService 类，在删除掉 SearchComponent 代码后会出现在 MainActivity 中 ServiceFactory.getInstance().getmSearchService()为 null的情况，就会报空指针，那么添加 Empty***Service 类就会规避这些问题。 以上内容均来自 网易公开课，感谢。 他山之石1、Android 高级开发工程师 网易公开课 PS: https://github.com/JinchaoWen/ComponentDemo码字不易，给个赞吧。赠人玫瑰，手留余香~]]></content>
      <tags>
        <tag>Android World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter实践——AndroidStudio环境初体验]]></title>
    <url>%2F2018%2F12%2F29%2FFlutter-Practice%E2%80%94%E2%80%94AS-Platform-First-Try%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是一篇菜鸟萌新初次上手Flutter的实践过程记录，老鸟请自行略过哈~最近大家都在说Flutter，还不是因为Google爸爸刚刚发布了Flutter 1.0 版本，简单了解了下，类似于微信小程序等等的一种跨平台解决方案，操作流畅度据说不管是iOS，还是Android，都可以“如丝般顺滑”，这么腻害？赶紧入坑看一看~ Flutter简介&emsp;&emsp;简介啥的自己查一查看看就好，不过这一篇还是比较好的，传送门：Flutter - 不一样的跨平台解决方案 。老实说这篇实践就是根据它来的，哈哈哈哈，感谢大佬！ Flutter安装配置&emsp;&emsp;本文介绍的是在Windows10系统上AndroidStudio中安装配置Flutter的方法和步骤，其他系统环境欢迎查看参考文献1.&emsp;&emsp;Flutter中文网是个不错的网站，居然有中文文档不错不错，自学能力不错的可以自己捣鼓。首先，要添加环境变量到自己的用户环境变量中。国内访问Flutter有时可能会受到限制（会科学上网的可自行忽略），Flutter官方就为中国开发者搭建了临时镜像下载window版本的Flutter资源文件，大家可以将如下环境变量加入到用户环境变量中：12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn &emsp;&emsp;这个是Linux系统的命令，在windows系统中也很简单，就是配置环境变量：注意：这镜像还只是临时的，万一哪天和组织联系不上了，还有组织留下的线索——Using Flutter in China。上面环境变量设置完之后就可以开始下载Flutter安装包了。Using Flutter in China这个网址不仅有官方下载原地址，还有镜像下载地址：Original URL: https://storage.googleapis.com/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zipMirrored URL:https://storage.flutter-io.cn/flutter_infra/releases/stable/windows/flutter_windows_v1.0.0-stable.zip我是用镜像地址下载的，速度很快，亲试有效。不仅如此，这个网址还提供了上海交通大学的镜像地址，如果之前设置的地址不能访问，可以设置这个地址，设置方法和之前环境配置一样：FLUTTER_STORAGE_BASE_URL: https://mirrors.sjtug.sjtu.edu.cn/PUB_HOSTED_URL: https://dart-pub.mirrors.sjtug.sjtu.edu.cn/&emsp;&emsp;将Flutter下载完成之后，将其解压放在权限较低的文件目录中，不建议放在X:/Program Files目录下，建议放在别的目录中：&emsp;&emsp;然后进入目录中，双击打开 flutter-console.bat ，进入Flutter命令行窗口：图中可以看出怎样在cmd中直接运用flutter的命令，无非就是将flutter的路径添加到系统环境变量中。&emsp;&emsp;输入命令检查Flutter安装情况：1flutter doctor 出现XX或者！的地方都是有问题的，比如说我这里有4个问题： Some Android licenses not accepted Flutter plugin not installed Dart plugin not installed No devices available 第一个问题，只需要如图中所示执行下面命令，然后一路输入“y”同意即可：1flutter doctor --android-licenses 在这里我遇到了一个问题，提醒说 A newer version of the Android SDK is required. To update, run:/Users/iOSCMB/AndroidStudio/SDK/tools/bin/sdkmanager –update 但是当我在命令行中执行这个命令的时候，又报错。报错信息是： Warning:An error occurred during installation:Failed to move away or delete existing target file: D:\User\XXX\Android\SDK\toolsMove it away manually and try again.. 千万不要按照它所说的把这个目录给删除，这是没有给Android SDK授权的原因，我们可以在命令后加 -v 来查看更详细的报错信息：1sdkmanager --update -v 根据它所说的，先给它授权，执行下面的命令：1sdkmanager --licenses 然后一路授权就可以了。 接下来的两个问题就要在AndroidStudio中解决了。 AndroidStudio安装Flutter和Dart插件&emsp;&emsp;在安装这两个插件之前，确保自己的AndroidStudio版本在3.1以上，我自己用的是3.2.1的版本，打开File—Settings—Plugins，在搜索框中搜索Flutter，点击install进行安装，Dart插件会一并进行下载安装。如果无法下载，可以将File-&gt;Settings-&gt;Apparence &amp; Behavior-&gt;System Settings-&gt;Updates-&gt;use secure connnection 勾去掉，我就出现了这个问题，去掉之后就可以下载插件了。&emsp;&emsp;都安装之后重启IDE，就可以发现New下面多了创建Flutter Project入口：这就说明安装成功，然后连接手机，打开USB调试，再输入flutter doctor进行检测，就会发现没有问题了。 Flutter Hello World&emsp;&emsp;建议编写Flutter程序在AndroidStudio工具上进行，与Android开发类似，支持断点调试等。在用AS正式开始之前要配置一下Flutter的SDK，如图所示：上述完成之后，就可以正式开始了。新建一个Flutter Project时，有四种方式：Flutter Application、Flutter Plugin、Flutter Package、Flutter Module这里直接选择默认第一个Flutter Application就行，进去之后大概就是这个样子：&emsp;&emsp;这里有一定的概率会卡死在创建项目的界面，可以唤起资源管理器强制停止，然后再重新从创建好的flutter项目中打开，根据指引 run 一下dart的资源就可以了。注意：连接真机后部署，可能会部署很长一段时间，卡在 initializing gradle 很久，这是因为它默认是要下载最新的Gradle版本的，而不是科学上网的你…就需要等很久很久，如果你打开你的C:\Users\你的用户名.gradle\wrapper\dists 就会发现多了存放最新Gradle版本的一个文件夹，比如我就多了“gradle-4.10.2-all”这个文件夹，最简单的方法就是将这个新建Flutter项目所用的Gradle版本设置成已有的Gradle版本，这里我改成了已有的gradle-4.6的版本。当然也可以用文献4的方法进行修改。&emsp;&emsp;OK，到此就可以成功部署了，我感觉部署的时间还是有点长的，不知是不是第一次编译的原因。Enjoy Yourself ！ 参考文献1、Flutter - 不一样的跨平台解决方案2、Using Flutter in China3、android studio 无法下载插件4、Flutter在Android Studio上的初启动]]></content>
      <tags>
        <tag>Android World</tag>
      </tags>
  </entry>
</search>
